# =============================================================================
# SatGate Gateway Mode: NGINX + OpenResty (Lua) Integration
# =============================================================================
#
# This configuration uses NGINX with OpenResty (Lua) for proper 402 handling.
# The auth_request module cannot natively handle 402 responses with bodies,
# so we use Lua to properly proxy the full response.
#
# Prerequisites:
#   - OpenResty or NGINX + lua-nginx-module
#   - lua-resty-http module (for HTTP client)
#
# Install on Ubuntu/Debian:
#   apt install openresty
#   opm get ledgetech/lua-resty-http
#
# How it works:
#   1. Request arrives at NGINX
#   2. Lua calls SatGate /auth/decide with request metadata
#   3. If 200: continue to upstream
#   4. If 402/403/429: return that response directly to client
#   5. If 5xx: fail closed (503)
#

http {
    # Lua package path for resty modules
    lua_package_path "/usr/local/openresty/lualib/?.lua;;";

    # Upstream for your actual backend (protected API)
    upstream backend {
        server 10.0.2.10:8080;
        keepalive 32;
    }

    # SatGate admin plane (runs /auth/decide)
    upstream satgate_auth {
        server 127.0.0.1:9090;
        keepalive 16;
    }

    # Shared dict for caching (optional, for positive auth caching)
    lua_shared_dict auth_cache 10m;

    server {
        listen 80;
        server_name api.example.com;

        # Access log format with SatGate headers
        log_format satgate '$remote_addr - $remote_user [$time_local] '
                          '"$request" $status $body_bytes_sent '
                          '"$http_referer" "$http_user_agent" '
                          'sg_route="$upstream_http_x_satgate_route" '
                          'sg_tier="$upstream_http_x_satgate_tier"';
        access_log /var/log/nginx/satgate.log satgate;

        # Protected API routes
        location /v1/ {
            # Call Lua auth handler
            access_by_lua_block {
                local http = require "resty.http"
                local httpc = http.new()
                
                -- Set timeouts (connect, send, read) in milliseconds
                httpc:set_timeouts(1000, 1000, 5000)
                
                -- Connect to SatGate auth service
                local ok, err = httpc:connect("127.0.0.1", 9090)
                if not ok then
                    ngx.log(ngx.ERR, "[SatGate] Connect error: ", err)
                    ngx.status = 503
                    ngx.header["Content-Type"] = "application/json"
                    ngx.header["Cache-Control"] = "no-store"
                    ngx.say('{"error":"Service Unavailable","message":"Auth service unreachable"}')
                    return ngx.exit(503)
                end
                
                -- Build auth request
                local res, err = httpc:request({
                    method = "POST",
                    path = "/auth/decide",
                    headers = {
                        ["Content-Type"] = "application/json",
                        ["X-Original-Method"] = ngx.req.get_method(),
                        ["X-Original-URI"] = ngx.var.request_uri,
                        ["X-Original-Host"] = ngx.var.host,
                        ["X-Original-Proto"] = ngx.var.scheme,
                        -- Preserve full forwarded chain when NGINX is behind a proxy/LB
                        ["X-Forwarded-For"] = ngx.var.proxy_add_x_forwarded_for,
                        ["X-Request-Id"] = ngx.var.request_id or ngx.var.connection .. "-" .. ngx.now(),
                        ["Authorization"] = ngx.var.http_authorization or ""
                    }
                })
                
                if not res then
                    ngx.log(ngx.ERR, "[SatGate] Request error: ", err)
                    ngx.status = 503
                    ngx.header["Content-Type"] = "application/json"
                    ngx.header["Cache-Control"] = "no-store"
                    ngx.say('{"error":"Service Unavailable","message":"Auth request failed"}')
                    return ngx.exit(503)
                end
                
                -- Read response body
                local body, err = res:read_body()
                
                -- Handle based on status
                if res.status == 200 then
                    -- Allowed - set headers for upstream and continue
                    ngx.req.set_header("X-SatGate-Route", res.headers["x-satgate-route"] or "")
                    ngx.req.set_header("X-SatGate-Tier", res.headers["x-satgate-tier"] or "")
                    ngx.req.set_header("X-Calls-Remaining", res.headers["x-calls-remaining"] or "")
                    ngx.req.set_header("X-Budget-Remaining", res.headers["x-budget-remaining"] or "")
                    -- Continue to proxy_pass
                    
                elseif res.status == 402 then
                    -- Payment required - return 402 with full challenge
                    ngx.status = 402
                    ngx.header["Content-Type"] = res.headers["content-type"] or "application/json"
                    ngx.header["WWW-Authenticate"] = res.headers["www-authenticate"] or ""
                    ngx.header["X-L402-Price"] = res.headers["x-l402-price"] or ""
                    ngx.header["X-L402-Tier"] = res.headers["x-l402-tier"] or ""
                    ngx.header["X-L402-TTL"] = res.headers["x-l402-ttl"] or ""
                    ngx.header["X-L402-Max-Calls"] = res.headers["x-l402-max-calls"] or ""
                    ngx.header["X-Request-Id"] = res.headers["x-request-id"] or ""
                    ngx.header["Cache-Control"] = "no-store"
                    ngx.header["Pragma"] = "no-cache"
                    ngx.say(body)
                    return ngx.exit(402)
                    
                elseif res.status == 403 then
                    -- Forbidden
                    ngx.status = 403
                    ngx.header["Content-Type"] = res.headers["content-type"] or "application/json"
                    ngx.header["X-Request-Id"] = res.headers["x-request-id"] or ""
                    ngx.header["Cache-Control"] = "no-store"
                    ngx.say(body)
                    return ngx.exit(403)
                    
                elseif res.status == 429 then
                    -- Rate/call limit
                    ngx.status = 429
                    ngx.header["Content-Type"] = res.headers["content-type"] or "application/json"
                    ngx.header["X-Request-Id"] = res.headers["x-request-id"] or ""
                    ngx.header["Cache-Control"] = "no-store"
                    ngx.say(body)
                    return ngx.exit(429)
                    
                else
                    -- Unexpected status - fail closed
                    ngx.log(ngx.ERR, "[SatGate] Unexpected status: ", res.status)
                    ngx.status = 503
                    ngx.header["Content-Type"] = "application/json"
                    ngx.header["Cache-Control"] = "no-store"
                    ngx.say('{"error":"Service Unavailable","message":"Unexpected auth response"}')
                    return ngx.exit(503)
                end
                
                -- Return connection to pool
                httpc:set_keepalive(60000, 100)
            }
            
            # If auth passed, proxy to backend
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Connection "";
        }

        # Health check (no auth)
        location /health {
            proxy_pass http://backend;
        }

        # Error pages
        error_page 500 502 503 504 /50x.html;
        location = /50x.html {
            root /usr/share/nginx/html;
            internal;
        }
    }
}

